package resources;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * Represents the configuration of an XMLValidator or a Migration object.
 * 
 * Holds field variables for files required to complete a full migration sequence,
 * as well as variables to determine how to display the information.
 * <br><br>
 * includes the private guessmap method, which is used by the constructor to create a map
 * when the check and reference xml strings are specified but the map is not.
 * <br>
 *  this maps <br>
	 * element tag name -> attribute tag name <br>
	 * <br>
	 * where attribute tag satisfies these constraints<br>
	 * for a given set of elements sharing the tag name key<br>
	 * <ul>
	 * <li>The attribute is present in every element key</li>
	 * <li>The attribute value is different for every element key</li>
	 * </ul>
 *
 * @author Mike Della Donna (mpdella@us.ibm.com)
 *
 */
public class Configuration {

	//pathnames for the 4 files require for a correct migration sequence.
	//only the first 2 are required for XMLValidator
	public String XMLcheck;
	public String XMLref;
	public String XSD;
	public String XSL;
	
	//variables that determine the type of HCI
	public String displayType = "";
	public String displayLength = "";
	public String outputFile = "";
	
	//a map that is used by XMLValidator to understand 
	//which elements of an XML document have the same tag, 
	//but can be differentiated by a specific attribute
	//usually automatically generated by the guess map method
	public Map<String, String> refMap;
	
	//empty constructor
	public Configuration(){}

	/**
	 * @param xMLcheck
	 * @param xMLref
	 * @param xSD
	 * @param xSL
	 * @param displayType
	 * @param displayLength
	 * @param outputFile
	 */
	public Configuration(String xMLcheck, String xMLref, String xSD,
			String xSL, String displayType, String displayLength,
			String outputFile) {
		XMLcheck = xMLcheck;
		XMLref = xMLref;
		XSD = xSD;
		XSL = xSL;
		this.displayType = displayType;
		this.displayLength = displayLength;
		this.outputFile = outputFile;
	}

	/**
	 * @param xMLcheck
	 * @param xMLref
	 * @param xSD
	 * @param xSL
	 * @param displayType
	 * @param displayLength
	 * @param outputFile
	 * @param refMap
	 */
	public Configuration(String xMLcheck, String xMLref, String xSD,
			String xSL, String displayType, String displayLength,
			String outputFile, Map<String, String> refMap) {
		XMLcheck = xMLcheck;
		XMLref = xMLref;
		XSD = xSD;
		XSL = xSL;
		this.displayType = displayType;
		this.displayLength = displayLength;
		this.outputFile = outputFile;
		this.refMap = refMap;
	}

	/**
	 * @param xMLcheck
	 * @param xMLref
	 * @param displayType
	 * @param displayLength
	 * @param outputFile
	 * @param refMap
	 */
	public Configuration(String xMLcheck, String xMLref, String displayType,
			String displayLength, String outputFile, Map<String, String> refMap) {
		XMLcheck = xMLcheck;
		XMLref = xMLref;
		this.displayType = displayType;
		this.displayLength = displayLength;
		this.outputFile = outputFile;
		this.refMap = refMap;
	}

	/**
	 * @param xMLcheck
	 * @param xMLref
	 * @param refMap
	 */
	public Configuration(String xMLcheck, String xMLref,
			Map<String, String> refMap) {
		XMLcheck = xMLcheck;
		XMLref = xMLref;
		this.refMap = refMap;
	}
	
	/**
	 * this constructor make a guess at assembling the map of multiple elements, where others 
	 * just use a blank map.
	 * @param xMLcheck
	 * @param xMLref
	 * @param displayType
	 * @param displayLength
	 * @param outputFile
	 */
	public Configuration(String xMLcheck, String xMLref, String displayType,
			String displayLength, String outputFile) {
		XMLcheck = xMLcheck;
		XMLref = xMLref;
		this.displayType = displayType;
		this.displayLength = displayLength;
		this.outputFile = outputFile;
		
		this.refMap = guessMap();
		
	}
	
	/**
	 * this constructor make a guess at assembling the map of multiple elements, where others 
	 * just use a blank map.
	 * without the display type specified, output will default to the console.
	 * @param xMLcheck
	 * @param xMLref
	 */
	public Configuration(String xMLcheck, String xMLref) {
		XMLcheck = xMLcheck;
		XMLref = xMLref;
		refMap = guessMap();
	}
	
	/**
	 * @return the xMLcheck
	 */
	public String getXMLcheck() {
		return XMLcheck;
	}

	/**
	 * @return the xMLref
	 */
	public String getXMLref() {
		return XMLref;
	}

	/**
	 * @return the displayType
	 */
	public String getDisplayType() {
		return displayType;
	}

	/**
	 * @return the displayLength
	 */
	public String getDisplayLength() {
		return displayLength;
	}

	/**
	 * @return the outputFile
	 */
	public String getOutputFile() {
		return outputFile;
	}

	/**
	 * @return the refMap
	 */
	public Map<String, String> getRefMap() {
		return refMap;
	}

	/**
	 * @param xMLcheck the xMLcheck to set
	 */
	public void setXMLcheck(String xMLcheck) {
		XMLcheck = xMLcheck;
	}

	/**
	 * @param xMLref the xMLref to set
	 */
	public void setXMLref(String xMLref) {
		XMLref = xMLref;
	}

	/**
	 * @param displayType the displayType to set
	 */
	public void setDisplayType(String displayType) {
		this.displayType = displayType;
	}

	/**
	 * @param displayLength the displayLength to set
	 */
	public void setDisplayLength(String displayLength) {
		this.displayLength = displayLength;
	}

	/**
	 * @param outputFile the outputFile to set
	 */
	public void setOutputFile(String outputFile) {
		this.outputFile = outputFile;
	}

	/**
	 * @param refMap the refMap to set
	 */
	public void setRefMap(Map<String, String> refMap) {
		this.refMap = refMap;
	}
	
	/**
	 * guessMap()
	 * makes a guess at assembling the multiple element map needed by XMLValidator
	 * <br>
	 * this maps <br>
	 * element tag name -> attribute tag name <br>
	 * <br>
	 * where attribute tag satisfies these constraints<br>
	 * for a given set of elements sharing the tag name key<br>
	 * <ul>
	 * <li>The attribute is present in every element key</li>
	 * <li>The attribute value is different for every element key</li>
	 * </ul>
	 * 
	 * @return Map<String, String>
	 */
	private Map<String, String> guessMap()
	{
		Map<String, String> tempMap = new HashMap<String, String>();
		
		//get all the elements in the reference doc
		Document doc = XMLUtilities.getXMLDoc(XMLref);
		NodeList allElements = doc.getElementsByTagName("*");
		
		//make a list of all the elements that occur more than once
		ArrayList<String> temp = new ArrayList<String>();
		ArrayList<String> multi = new ArrayList<String>();
		
		for(int i = 0; i < allElements.getLength(); i++)
		{
			if(temp.contains(allElements.item(i).getNodeName()))
			{
				if(!multi.contains(allElements.item(i).getNodeName()))
					{multi.add(allElements.item(i).getNodeName());}
			}
			else
			{
				temp.add(allElements.item(i).getNodeName());
			}
		}
		//multi now contains all the elements that occur more than once
		
		//if multi is empty, we don't have to go any further, this document doesnt have any multiples
		if(multi.isEmpty())
			return tempMap;
		
		//if multi is not empty, then we need to figure out how to identify the elements in it
		NodeList multiEl;
		NamedNodeMap attr;
		ArrayList<String> commAttr;
		boolean exist;
		boolean noUniqueAttributes;
		Set<String> attrSet;
		boolean noMeanigfulTextContent;
		NodeList children;
		
		//look through all the strings in multi, these are all the tags that occur more than once
		for(String s : multi)
		{
			multiEl = doc.getElementsByTagName(s);
			
			//look through all these elements and determine which attributes are common to all of them.
			commAttr = new ArrayList<String>();
			
			//get a list of the attributes of the first element.  the set of all common attributes must be a subset of this
			attr = multiEl.item(0).getAttributes();
			
			//look through this list of attributes, and determine if they exist in every other element
			for(int j = 0; j < attr.getLength(); j++)
			{
				exist = true;
				for(int i = 1; i < multiEl.getLength(); i++)
				{
					if(multiEl.item(i).getAttributes().getNamedItem(attr.item(j).getNodeName()) == null)
					{
						exist = false;
					}
				}
				
				//if the attribute exists in every other element, add it to this list.
				if(exist)
				{
					commAttr.add(attr.item(j).getNodeName());
				}
			}
			
			noUniqueAttributes = true;
			//we now have a list of all the attributes common to every element
			//identify attributes that have unique values for every element
			for(String sa : commAttr)
			{
				//create a set of the values of the current attribute
				attrSet = new HashSet<String>();
				for(int i = 0; i < multiEl.getLength(); i++)
				{
					attrSet.add(multiEl.item(i).getAttributes().getNamedItem(sa).getNodeValue());
				}
				
				//if the size of the set is the same as the number of elements,
				//it means that there is a unique value for every element.
				//add this combination of <element tag, attribute name> to the map
				//done, we only need one unique attribute per element
				if(attrSet.size() == multiEl.getLength())
				{
					tempMap.put(multiEl.item(0).getNodeName(), sa);
					noUniqueAttributes = false;
					break;
				}
			}
			
			
			//these tags have no unique attributes, now we'll check to see if they
			//have any text values that are meaningful (not whitespace chars)
			noMeanigfulTextContent = false;
			if(noUniqueAttributes)
			{
				for(int i = 0; i < multiEl.getLength(); i++)
				{
					//no child nodes means this node can't be distinguished by text
					if(multiEl.item(i).hasChildNodes())
					{
						children = multiEl.item(i).getChildNodes();
						exist = false;
						//check all the child nodes
						for(int j = 0; j < children.getLength(); j++)
						{
							//check for text nodes
							if(children.item(j).getNodeType() == Node.TEXT_NODE)
							{
								//check to make sure the text nodes contain meaningful data, not just whitespace
								//the java regex \s matches "A whitespace character: [ \t\n\x0B\f\r]"
								if(children.item(j).getNodeValue().replaceAll("\\s", "").length() > 0)
								{
									//this means that the element has a text node that has meaningful data
									//also we can stop looking now
									//update the map with a special keyword
									tempMap.put(multiEl.item(0).getNodeName(), "TEXTTEXT");
									exist = true;
									break;
								}
							}
						}
						
						if(!exist)
						{
							noMeanigfulTextContent = true;
							break;
						}
					}
					else
					{
						noMeanigfulTextContent = true;
						break;
					}
				}
				
				//this group of elements contains entries that have no unique identifying information
				//this probably means the nodes are context sensitive, and outside the scope of this operation
				//we can safely ignore them for now
				if(noMeanigfulTextContent)
				{
					tempMap.put(multiEl.item(0).getNodeName(), null);
				}
			}
			
			
		}
		
		
		return tempMap;
	}

	/**
	 * @return the file path to the schema file
	 */
	public String getXSD() {
		return XSD;
	}

	/**
	 * @param xSD a string representing the path to the new XSD file
	 */
	public void setXSD(String xSD) {
		XSD = xSD;
	}

	/**
	 * @return String - the XSL path held by this object
	 */
	public String getXSL() {
		return XSL;
	}

	
	/**
	 * @param xSL - a string representing the path to the new XSL file
	 */
	public void setXSL(String xSL) {
		XSL = xSL;
	}
}

