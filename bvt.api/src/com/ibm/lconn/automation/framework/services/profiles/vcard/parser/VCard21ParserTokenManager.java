/* ***************************************************************** */
/*                                                                   */
/* IBM Confidential                                                  */
/*                                                                   */
/* OCO Source Materials                                              */
/*                                                                   */
/* Copyright IBM Corp. 2015                                          */
/*                                                                   */
/* The source code for this program is not published or otherwise    */
/* divested of its trade secrets, irrespective of what has been      */
/* deposited with the U.S. Copyright Office.                         */
/*                                                                   */
/* ***************************************************************** */

/* Generated By:JavaCC: Do not edit this line. VCard21ParserTokenManager.java */

package com.ibm.lconn.automation.framework.services.profiles.vcard.parser;

/** Token Manager. */
public class VCard21ParserTokenManager implements VCard21ParserConstants {
	/** Debug output. */
	public java.io.PrintStream debugStream = System.out;

	/** Set debug output. */
	public void setDebugStream(java.io.PrintStream ds) {
		debugStream = ds;
	}

	private final int jjStopStringLiteralDfa_0(int pos, long active0) {
		switch (pos) {
			default:
				return -1;
		}
	}

	private final int jjStartNfa_0(int pos, long active0) {
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
	}

	private int jjStopAtPos(int pos, int kind) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}

	private int jjMoveStringLiteralDfa0_0() {
		switch (curChar) {
			case 46 :
				return jjStopAtPos(0, 19);
			case 58 :
				return jjStopAtPos(0, 4);
			case 59 :
				return jjStartNfaWithStates_0(0, 6, 58);
			case 61 :
				return jjStopAtPos(0, 8);
			default:
				return jjMoveNfa_0(15, 0);
		}
	}

	private int jjStartNfaWithStates_0(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = input_stream.readChar();
		}
		catch (java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_0(state, pos + 1);
	}
	static final long[] jjbitVec0 = { 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL };
	static final long[] jjbitVec2 = { 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL };

	private int jjMoveNfa_0(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 74;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff) ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				do {
					switch (jjstateSet[--i]) {
						case 15 :
							if ((0x100000200L & l) != 0L) {
								if (kind > 12) kind = 12;
								jjCheckNAdd(30);
							}
							else if (curChar == 59)
								jjAddStates(0, 1);
							else if (curChar == 10) {
								if (kind > 1) kind = 1;
								jjCheckNAddTwoStates(1, 2);
							}
							else if (curChar == 13) jjstateSet[jjnewStateCnt++] = 0;
							break;
						case 0 :
							if (curChar != 10) break;
							if (kind > 1) kind = 1;
							jjCheckNAddTwoStates(1, 2);
							break;
						case 1 :
							if (curChar == 13) jjstateSet[jjnewStateCnt++] = 0;
							break;
						case 2 :
							if (curChar != 10) break;
							if (kind > 1) kind = 1;
							jjCheckNAddTwoStates(1, 2);
							break;
						case 4 :
							if ((0x100000200L & l) != 0L) jjAddStates(2, 3);
							break;
						case 5 :
							if (curChar == 58) jjCheckNAddTwoStates(6, 11);
							break;
						case 6 :
							if ((0x100000200L & l) != 0L) jjCheckNAddTwoStates(6, 11);
							break;
						case 17 :
							if ((0x100000200L & l) != 0L) jjAddStates(4, 5);
							break;
						case 18 :
							if (curChar == 58) jjCheckNAddTwoStates(19, 24);
							break;
						case 19 :
							if ((0x100000200L & l) != 0L) jjCheckNAddTwoStates(19, 24);
							break;
						case 28 :
							if (curChar == 45) jjCheckNAdd(29);
							break;
						case 29 :
							if ((0xf3ffffffffffdbffL & l) == 0L) break;
							if (kind > 11) kind = 11;
							jjCheckNAdd(29);
							break;
						case 30 :
							if ((0x100000200L & l) == 0L) break;
							if (kind > 12) kind = 12;
							jjCheckNAdd(30);
							break;
						case 32 :
							if ((0x3ff200000000000L & l) == 0L) break;
							if (kind > 13) kind = 13;
							jjstateSet[jjnewStateCnt++] = 32;
							break;
						case 33 :
							if (curChar == 59) jjAddStates(0, 1);
							break;
						case 43 :
							if (curChar == 45) jjstateSet[jjnewStateCnt++] = 42;
							break;
						case 50 :
							if (curChar == 61) jjstateSet[jjnewStateCnt++] = 49;
							break;
						case 67 :
							if (curChar == 45) jjstateSet[jjnewStateCnt++] = 66;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else if (curChar < 128) {
				long l = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 15 :
							if ((0x7fffffe07fffffeL & l) != 0L) {
								if (kind > 13) kind = 13;
								jjCheckNAdd(32);
							}
							if ((0x100000001000000L & l) != 0L)
								jjstateSet[jjnewStateCnt++] = 28;
							else if ((0x2000000020L & l) != 0L)
								jjstateSet[jjnewStateCnt++] = 25;
							else if ((0x400000004L & l) != 0L) jjstateSet[jjnewStateCnt++] = 14;
							break;
						case 58 :
							if ((0x2000000020000L & l) != 0L)
								jjstateSet[jjnewStateCnt++] = 72;
							else if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 57;
							break;
						case 3 :
							if ((0x400000004000L & l) != 0L) jjAddStates(2, 3);
							break;
						case 7 :
							if ((0x1000000010L & l) != 0L && kind > 9) kind = 9;
							break;
						case 8 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 7;
							break;
						case 9 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 8;
							break;
						case 10 :
							if ((0x800000008L & l) != 0L) jjstateSet[jjnewStateCnt++] = 9;
							break;
						case 11 :
							if ((0x40000000400000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 10;
							break;
						case 12 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 3;
							break;
						case 13 :
							if ((0x8000000080L & l) != 0L) jjstateSet[jjnewStateCnt++] = 12;
							break;
						case 14 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 13;
							break;
						case 16 :
							if ((0x1000000010L & l) != 0L) jjAddStates(4, 5);
							break;
						case 20 :
							if ((0x1000000010L & l) != 0L && kind > 10) kind = 10;
							break;
						case 21 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 20;
							break;
						case 22 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 21;
							break;
						case 23 :
							if ((0x800000008L & l) != 0L) jjstateSet[jjnewStateCnt++] = 22;
							break;
						case 24 :
							if ((0x40000000400000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 23;
							break;
						case 25 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 16;
							break;
						case 26 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 25;
							break;
						case 27 :
							if ((0x100000001000000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 28;
							break;
						case 28 :
							if (curChar == 95) jjCheckNAdd(29);
							break;
						case 29 :
							if (kind > 11) kind = 11;
							jjCheckNAdd(29);
							break;
						case 31 :
							if ((0x7fffffe07fffffeL & l) == 0L) break;
							if (kind > 13) kind = 13;
							jjCheckNAdd(32);
							break;
						case 32 :
							if ((0x7fffffe87fffffeL & l) == 0L) break;
							if (kind > 13) kind = 13;
							jjCheckNAdd(32);
							break;
						case 34 :
							if ((0x2000000020L & l) != 0L && kind > 17) kind = 17;
							break;
						case 35 :
						case 59 :
							if ((0x100000001000L & l) != 0L) jjCheckNAdd(34);
							break;
						case 36 :
							if ((0x400000004L & l) != 0L) jjstateSet[jjnewStateCnt++] = 35;
							break;
						case 37 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 36;
							break;
						case 38 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 37;
							break;
						case 39 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 38;
							break;
						case 40 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 39;
							break;
						case 41 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 40;
							break;
						case 42 :
							if ((0x1000000010000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 41;
							break;
						case 44 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 43;
							break;
						case 45 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 44;
							break;
						case 46 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 45;
							break;
						case 47 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 46;
							break;
						case 48 :
							if ((0x20000000200000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 47;
							break;
						case 49 :
							if ((0x2000000020000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 48;
							break;
						case 51 :
							if ((0x8000000080L & l) != 0L) jjstateSet[jjnewStateCnt++] = 50;
							break;
						case 52 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 51;
							break;
						case 53 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 52;
							break;
						case 54 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 53;
							break;
						case 55 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 54;
							break;
						case 56 :
							if ((0x800000008L & l) != 0L) jjstateSet[jjnewStateCnt++] = 55;
							break;
						case 57 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 56;
							break;
						case 60 :
							if ((0x400000004L & l) != 0L) jjstateSet[jjnewStateCnt++] = 59;
							break;
						case 61 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 60;
							break;
						case 62 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 61;
							break;
						case 63 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 62;
							break;
						case 64 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 63;
							break;
						case 65 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 64;
							break;
						case 66 :
							if ((0x1000000010000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 65;
							break;
						case 68 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 67;
							break;
						case 69 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 68;
							break;
						case 70 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 69;
							break;
						case 71 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 70;
							break;
						case 72 :
							if ((0x20000000200000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 71;
							break;
						case 73 :
							if ((0x2000000020000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 72;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 29 :
							if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
							if (kind > 11) kind = 11;
							jjstateSet[jjnewStateCnt++] = 29;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 74 - (jjnewStateCnt = startsAt))) return curPos;
			try {
				curChar = input_stream.readChar();
			}
			catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	private final int jjStopStringLiteralDfa_4(int pos, long active0) {
		switch (pos) {
			default:
				return -1;
		}
	}

	private final int jjStartNfa_4(int pos, long active0) {
		return jjMoveNfa_4(jjStopStringLiteralDfa_4(pos, active0), pos + 1);
	}

	private int jjMoveStringLiteralDfa0_4() {
		switch (curChar) {
			case 58 :
				return jjStopAtPos(0, 5);
			case 59 :
				return jjStartNfaWithStates_4(0, 7, 26);
			case 61 :
				return jjStopAtPos(0, 8);
			default:
				return jjMoveNfa_4(1, 0);
		}
	}

	private int jjStartNfaWithStates_4(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = input_stream.readChar();
		}
		catch (java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_4(state, pos + 1);
	}

	private int jjMoveNfa_4(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 42;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff) ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				do {
					switch (jjstateSet[--i]) {
						case 1 :
							if ((0xd3ffffffffffd9ffL & l) != 0L) {
								if (kind > 18) kind = 18;
								jjCheckNAdd(0);
							}
							else if (curChar == 59) jjAddStates(6, 7);
							break;
						case 0 :
							if ((0xd3ffffffffffd9ffL & l) == 0L) break;
							if (kind > 18) kind = 18;
							jjCheckNAdd(0);
							break;
						case 11 :
							if (curChar == 45) jjstateSet[jjnewStateCnt++] = 10;
							break;
						case 18 :
							if (curChar == 61) jjstateSet[jjnewStateCnt++] = 17;
							break;
						case 35 :
							if (curChar == 45) jjstateSet[jjnewStateCnt++] = 34;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else if (curChar < 128) {
				long l = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 1 :
						case 0 :
							if ((0xffffffffd7ffffffL & l) == 0L) break;
							if (kind > 18) kind = 18;
							jjCheckNAdd(0);
							break;
						case 26 :
							if ((0x2000000020000L & l) != 0L)
								jjstateSet[jjnewStateCnt++] = 40;
							else if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 25;
							break;
						case 2 :
							if ((0x2000000020L & l) != 0L && kind > 17) kind = 17;
							break;
						case 3 :
						case 27 :
							if ((0x100000001000L & l) != 0L) jjCheckNAdd(2);
							break;
						case 4 :
							if ((0x400000004L & l) != 0L) jjstateSet[jjnewStateCnt++] = 3;
							break;
						case 5 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 4;
							break;
						case 6 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 5;
							break;
						case 7 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 6;
							break;
						case 8 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 7;
							break;
						case 9 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 8;
							break;
						case 10 :
							if ((0x1000000010000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 9;
							break;
						case 12 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 11;
							break;
						case 13 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 12;
							break;
						case 14 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 13;
							break;
						case 15 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 14;
							break;
						case 16 :
							if ((0x20000000200000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 15;
							break;
						case 17 :
							if ((0x2000000020000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 16;
							break;
						case 19 :
							if ((0x8000000080L & l) != 0L) jjstateSet[jjnewStateCnt++] = 18;
							break;
						case 20 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 19;
							break;
						case 21 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 20;
							break;
						case 22 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 21;
							break;
						case 23 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 22;
							break;
						case 24 :
							if ((0x800000008L & l) != 0L) jjstateSet[jjnewStateCnt++] = 23;
							break;
						case 25 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 24;
							break;
						case 28 :
							if ((0x400000004L & l) != 0L) jjstateSet[jjnewStateCnt++] = 27;
							break;
						case 29 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 28;
							break;
						case 30 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 29;
							break;
						case 31 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 30;
							break;
						case 32 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 31;
							break;
						case 33 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 32;
							break;
						case 34 :
							if ((0x1000000010000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 33;
							break;
						case 36 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 35;
							break;
						case 37 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 36;
							break;
						case 38 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 37;
							break;
						case 39 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 38;
							break;
						case 40 :
							if ((0x20000000200000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 39;
							break;
						case 41 :
							if ((0x2000000020000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 40;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 1 :
						case 0 :
							if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
							if (kind > 18) kind = 18;
							jjCheckNAdd(0);
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 42 - (jjnewStateCnt = startsAt))) return curPos;
			try {
				curChar = input_stream.readChar();
			}
			catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	private int jjMoveStringLiteralDfa0_1() {
		return jjMoveNfa_1(1, 0);
	}

	private int jjMoveNfa_1(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 10;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff) ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				do {
					switch (jjstateSet[--i]) {
						case 1 :
							if ((0xffffffffffffdbffL & l) != 0L) {
								if (kind > 14) kind = 14;
								jjCheckNAdd(0);
							}
							else if (curChar == 10) {
								if (kind > 1) kind = 1;
								jjCheckNAddStates(8, 12);
							}
							else if (curChar == 13) jjCheckNAddTwoStates(2, 5);
							break;
						case 0 :
							if ((0xffffffffffffdbffL & l) == 0L) break;
							if (kind > 14) kind = 14;
							jjCheckNAdd(0);
							break;
						case 2 :
						case 4 :
							if (curChar != 10) break;
							if (kind > 1) kind = 1;
							jjCheckNAddTwoStates(3, 4);
							break;
						case 3 :
							if (curChar == 13) jjCheckNAdd(2);
							break;
						case 5 :
						case 7 :
							if (curChar == 10) jjCheckNAddStates(13, 15);
							break;
						case 6 :
							if (curChar == 13) jjCheckNAdd(5);
							break;
						case 8 :
							if ((0x100000200L & l) != 0L && kind > 2) kind = 2;
							break;
						case 9 :
							if (curChar != 10) break;
							if (kind > 1) kind = 1;
							jjCheckNAddStates(8, 12);
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else if (curChar < 128) {
				long l = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 1 :
						case 0 :
							kind = 14;
							jjCheckNAdd(0);
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 1 :
						case 0 :
							if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
							if (kind > 14) kind = 14;
							jjCheckNAdd(0);
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 10 - (jjnewStateCnt = startsAt))) return curPos;
			try {
				curChar = input_stream.readChar();
			}
			catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	private final int jjStopStringLiteralDfa_3(int pos, long active0) {
		switch (pos) {
			default:
				return -1;
		}
	}

	private final int jjStartNfa_3(int pos, long active0) {
		return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
	}

	private int jjMoveStringLiteralDfa0_3() {
		switch (curChar) {
			case 58 :
				return jjStopAtPos(0, 4);
			case 59 :
				return jjStartNfaWithStates_3(0, 6, 26);
			case 61 :
				return jjStopAtPos(0, 8);
			default:
				return jjMoveNfa_3(1, 0);
		}
	}

	private int jjStartNfaWithStates_3(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = input_stream.readChar();
		}
		catch (java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_3(state, pos + 1);
	}

	private int jjMoveNfa_3(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 42;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff) ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				do {
					switch (jjstateSet[--i]) {
						case 1 :
							if ((0xd3ffffffffffd9ffL & l) != 0L) {
								if (kind > 18) kind = 18;
								jjCheckNAdd(0);
							}
							else if (curChar == 59) jjAddStates(6, 7);
							break;
						case 0 :
							if ((0xd3ffffffffffd9ffL & l) == 0L) break;
							if (kind > 18) kind = 18;
							jjCheckNAdd(0);
							break;
						case 11 :
							if (curChar == 45) jjstateSet[jjnewStateCnt++] = 10;
							break;
						case 18 :
							if (curChar == 61) jjstateSet[jjnewStateCnt++] = 17;
							break;
						case 35 :
							if (curChar == 45) jjstateSet[jjnewStateCnt++] = 34;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else if (curChar < 128) {
				long l = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 1 :
						case 0 :
							if ((0xffffffffd7ffffffL & l) == 0L) break;
							if (kind > 18) kind = 18;
							jjCheckNAdd(0);
							break;
						case 26 :
							if ((0x2000000020000L & l) != 0L)
								jjstateSet[jjnewStateCnt++] = 40;
							else if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 25;
							break;
						case 2 :
							if ((0x2000000020L & l) != 0L && kind > 17) kind = 17;
							break;
						case 3 :
						case 27 :
							if ((0x100000001000L & l) != 0L) jjCheckNAdd(2);
							break;
						case 4 :
							if ((0x400000004L & l) != 0L) jjstateSet[jjnewStateCnt++] = 3;
							break;
						case 5 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 4;
							break;
						case 6 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 5;
							break;
						case 7 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 6;
							break;
						case 8 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 7;
							break;
						case 9 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 8;
							break;
						case 10 :
							if ((0x1000000010000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 9;
							break;
						case 12 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 11;
							break;
						case 13 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 12;
							break;
						case 14 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 13;
							break;
						case 15 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 14;
							break;
						case 16 :
							if ((0x20000000200000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 15;
							break;
						case 17 :
							if ((0x2000000020000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 16;
							break;
						case 19 :
							if ((0x8000000080L & l) != 0L) jjstateSet[jjnewStateCnt++] = 18;
							break;
						case 20 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 19;
							break;
						case 21 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 20;
							break;
						case 22 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 21;
							break;
						case 23 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 22;
							break;
						case 24 :
							if ((0x800000008L & l) != 0L) jjstateSet[jjnewStateCnt++] = 23;
							break;
						case 25 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 24;
							break;
						case 28 :
							if ((0x400000004L & l) != 0L) jjstateSet[jjnewStateCnt++] = 27;
							break;
						case 29 :
							if ((0x200000002L & l) != 0L) jjstateSet[jjnewStateCnt++] = 28;
							break;
						case 30 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 29;
							break;
						case 31 :
							if ((0x400000004000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 30;
							break;
						case 32 :
							if ((0x20000000200L & l) != 0L) jjstateSet[jjnewStateCnt++] = 31;
							break;
						case 33 :
							if ((0x4000000040000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 32;
							break;
						case 34 :
							if ((0x1000000010000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 33;
							break;
						case 36 :
							if ((0x1000000010L & l) != 0L) jjstateSet[jjnewStateCnt++] = 35;
							break;
						case 37 :
							if ((0x2000000020L & l) != 0L) jjstateSet[jjnewStateCnt++] = 36;
							break;
						case 38 :
							if ((0x10000000100000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 37;
							break;
						case 39 :
							if ((0x800000008000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 38;
							break;
						case 40 :
							if ((0x20000000200000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 39;
							break;
						case 41 :
							if ((0x2000000020000L & l) != 0L) jjstateSet[jjnewStateCnt++] = 40;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 1 :
						case 0 :
							if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
							if (kind > 18) kind = 18;
							jjCheckNAdd(0);
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 42 - (jjnewStateCnt = startsAt))) return curPos;
			try {
				curChar = input_stream.readChar();
			}
			catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	private final int jjStopStringLiteralDfa_2(int pos, long active0) {
		switch (pos) {
			default:
				return -1;
		}
	}

	private final int jjStartNfa_2(int pos, long active0) {
		return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
	}

	private int jjMoveStringLiteralDfa0_2() {
		switch (curChar) {
			case 61 :
				return jjStartNfaWithStates_2(0, 16, 6);
			default:
				return jjMoveNfa_2(4, 0);
		}
	}

	private int jjStartNfaWithStates_2(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = input_stream.readChar();
		}
		catch (java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_2(state, pos + 1);
	}

	private int jjMoveNfa_2(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 7;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff) ReInitRounds();
			if (curChar < 64) {
				long l = 1L << curChar;
				do {
					switch (jjstateSet[--i]) {
						case 6 :
							if (curChar == 10) {
								if (kind > 3) kind = 3;
							}
							else if (curChar == 13) jjCheckNAdd(5);
							break;
						case 4 :
							if ((0xdfffffffffffdbffL & l) != 0L) {
								if (kind > 15) kind = 15;
								jjCheckNAdd(3);
							}
							else if (curChar == 61)
								jjCheckNAddTwoStates(6, 5);
							else if (curChar == 10) {
								if (kind > 1) kind = 1;
								jjCheckNAddTwoStates(1, 2);
							}
							else if (curChar == 13) jjstateSet[jjnewStateCnt++] = 0;
							break;
						case 0 :
							if (curChar != 10) break;
							if (kind > 1) kind = 1;
							jjCheckNAddTwoStates(1, 2);
							break;
						case 1 :
							if (curChar == 13) jjstateSet[jjnewStateCnt++] = 0;
							break;
						case 2 :
							if (curChar != 10) break;
							if (kind > 1) kind = 1;
							jjCheckNAddTwoStates(1, 2);
							break;
						case 3 :
							if ((0xdfffffffffffdbffL & l) == 0L) break;
							kind = 15;
							jjCheckNAdd(3);
							break;
						case 5 :
							if (curChar == 10 && kind > 3) kind = 3;
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else if (curChar < 128) {
				long l = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 4 :
						case 3 :
							kind = 15;
							jjCheckNAdd(3);
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				long l1 = 1L << (hiByte & 077);
				int i2 = (curChar & 0xff) >> 6;
				long l2 = 1L << (curChar & 077);
				do {
					switch (jjstateSet[--i]) {
						case 4 :
						case 3 :
							if (!jjCanMove_0(hiByte, i1, i2, l1, l2)) break;
							if (kind > 15) kind = 15;
							jjCheckNAdd(3);
							break;
						default:
							break;
					}
				}
				while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt))) return curPos;
			try {
				curChar = input_stream.readChar();
			}
			catch (java.io.IOException e) {
				return curPos;
			}
		}
	}
	static final int[] jjnextStates = { 58, 73, 4, 5, 17, 18, 26, 41, 3, 4, 6, 7, 8, 6, 7, 8, };

	private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2) {
		switch (hiByte) {
			case 0 :
				return ((jjbitVec2[i2] & l2) != 0L);
			default:
				if ((jjbitVec0[i1] & l1) != 0L) return true;
				return false;
		}
	}

	/** Token literal values. */
	public static final String[] jjstrLiteralImages = { "", null, null, null, "\72", "\72", "\73", "\73", "\75", null, null, null, null,
			null, null, null, "\75", null, null, "\56", };

	/** Lexer state names. */
	public static final String[] lexStateNames = { "DEFAULT", "CONTENTSTATE", "CONTENTSTATE_QUOTED_PRINTABLE", "PARAMSTATE",
			"PARAMSTATE_QUOTED_PRINTABLE", };

	/** Lex State array. */
	public static final int[] jjnewLexState = { -1, 0, -1, -1, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, };
	protected SimpleCharStream input_stream;
	private final int[] jjrounds = new int[74];
	private final int[] jjstateSet = new int[148];
	protected char curChar;

	/** Constructor. */
	public VCard21ParserTokenManager(SimpleCharStream stream) {
		if (SimpleCharStream.staticFlag)
			throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
		input_stream = stream;
	}

	/** Constructor. */
	public VCard21ParserTokenManager(SimpleCharStream stream, int lexState) {
		this(stream);
		SwitchTo(lexState);
	}

	/** Reinitialise parser. */
	public void ReInit(SimpleCharStream stream) {
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}

	private void ReInitRounds() {
		int i;
		jjround = 0x80000001;
		for (i = 74; i-- > 0;)
			jjrounds[i] = 0x80000000;
	}

	/** Reinitialise parser. */
	public void ReInit(SimpleCharStream stream, int lexState) {
		ReInit(stream);
		SwitchTo(lexState);
	}

	/** Switch to specified lex state. */
	public void SwitchTo(int lexState) {
		if (lexState >= 5 || lexState < 0)
			throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.",
					TokenMgrError.INVALID_LEXICAL_STATE);
		else
			curLexState = lexState;
	}

	protected Token jjFillToken() {
		final Token t;
		final String curTokenImage;
		final int beginLine;
		final int endLine;
		final int beginColumn;
		final int endColumn;
		String im = jjstrLiteralImages[jjmatchedKind];
		curTokenImage = (im == null) ? input_stream.GetImage() : im;
		beginLine = input_stream.getBeginLine();
		beginColumn = input_stream.getBeginColumn();
		endLine = input_stream.getEndLine();
		endColumn = input_stream.getEndColumn();
		t = Token.newToken(jjmatchedKind, curTokenImage);

		t.beginLine = beginLine;
		t.endLine = endLine;
		t.beginColumn = beginColumn;
		t.endColumn = endColumn;

		return t;
	}

	int curLexState = 0;
	int defaultLexState = 0;
	int jjnewStateCnt;
	int jjround;
	int jjmatchedPos;
	int jjmatchedKind;

	/** Get the next Token. */
	public Token getNextToken() {
		Token matchedToken;
		int curPos = 0;

		EOFLoop: for (;;) {
			try {
				curChar = input_stream.BeginToken();
			}
			catch (java.io.IOException e) {
				jjmatchedKind = 0;
				matchedToken = jjFillToken();
				return matchedToken;
			}

			switch (curLexState) {
				case 0 :
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_0();
					break;
				case 1 :
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_1();
					break;
				case 2 :
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_2();
					break;
				case 3 :
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_3();
					break;
				case 4 :
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_4();
					break;
			}
			if (jjmatchedKind != 0x7fffffff) {
				if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1);
				matchedToken = jjFillToken();
				if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind];
				return matchedToken;
			}
			int error_line = input_stream.getEndLine();
			int error_column = input_stream.getEndColumn();
			String error_after = null;
			boolean EOFSeen = false;
			try {
				input_stream.readChar();
				input_stream.backup(1);
			}
			catch (java.io.IOException e1) {
				EOFSeen = true;
				error_after = curPos <= 1 ? "" : input_stream.GetImage();
				if (curChar == '\n' || curChar == '\r') {
					error_line++;
					error_column = 0;
				}
				else
					error_column++;
			}
			if (!EOFSeen) {
				input_stream.backup(1);
				error_after = curPos <= 1 ? "" : input_stream.GetImage();
			}
			throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
		}
	}

	private void jjCheckNAdd(int state) {
		if (jjrounds[state] != jjround) {
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}

	private void jjAddStates(int start, int end) {
		do {
			jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		}
		while (start++ != end);
	}

	private void jjCheckNAddTwoStates(int state1, int state2) {
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

	private void jjCheckNAddStates(int start, int end) {
		do {
			jjCheckNAdd(jjnextStates[start]);
		}
		while (start++ != end);
	}

}
